<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Gra w zapamiÄ™tywanie - Hub</title>
    <link rel="icon" type="image/x-icon" href="https://www.solojuve.com/spolecznosc/zdj%C4%99cia/306-bezimienny-jpg/pobierz">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #ffffff;
            --text: #1a1a1a;
            --text-secondary: #666;
            --border: #e0e0e0;
            --card-bg: #f8f9fa;
            --header-bg: #ffffff;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg: #1a1a1a;
            --text: #ffffff;
            --text-secondary: #aaa;
            --border: #333;
            --card-bg: #2a2a2a;
            --header-bg: #1a1a1a;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        html {
            background: var(--bg);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
        }

        header {
            background: var(--header-bg);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 4px var(--shadow);
        }

        nav {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text);
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            flex: 1;
        }

        .nav-links a {
            color: var(--text-secondary);
            text-decoration: none;
        }

        .nav-links a:hover,
        .nav-links a.active {
            color: var(--text);
        }

        #theme-toggle {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
        }

        main {
            max-width: 900px;
            margin: 0 auto;
            padding: 3rem 2rem;
        }

        .game-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .game-header p {
            color: var(--text-secondary);
            font-size: 1rem;
            margin-bottom: 1.5rem;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .stat {
            text-align: center;
        }

        .stat span {
            display: block;
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }

        .stat strong {
            font-size: 1.5rem;
            color: var(--text);
        }

        .restart-btn {
            padding: 0.75rem 1.5rem;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
            cursor: pointer;
        }

        .restart-btn:hover {
            background: var(--border);
        }

        .memory-grid {
            width: 100%;
            max-width: 720px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .memory-card {
            position: relative;
            aspect-ratio: 1 / 1;
            border-radius: 12px;
            border: 3px solid var(--border);
            background: var(--card-bg);
            box-shadow: 0 4px 12px var(--shadow);
            cursor: pointer;
            transition: all 0.2s;
        }

        .memory-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px var(--shadow);
        }

        .memory-card.hidden {
            background: var(--card-bg);
            border-color: var(--border);
        }

        .memory-card.off {
            cursor: default;
            opacity: 0;
            visibility: hidden;
        }

        .memory-card:not(.hidden).red { background-color: #ef4444; border-color: #dc2626; }
        .memory-card:not(.hidden).green { background-color: #22c55e; border-color: #16a34a; }
        .memory-card:not(.hidden).blue { background-color: #3b82f6; border-color: #2563eb; }
        .memory-card:not(.hidden).magenta { background-color: #e879f9; border-color: #d946ef; }
        .memory-card:not(.hidden).yellow { background-color: #facc15; border-color: #eab308; }
        .memory-card:not(.hidden).bisque { background-color: #fbbf24; border-color: #f59e0b; }
        .memory-card:not(.hidden).brown { background-color: #b45309; border-color: #92400e; }
        .memory-card:not(.hidden).cyan { background-color: #22d3ee; border-color: #06b6d4; }
        .memory-card:not(.hidden).orange { background-color: #fb923c; border-color: #f97316; }

        .message {
            text-align: center;
            color: var(--text);
            padding: 1rem;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 1rem;
            display: none;
        }

        .message.visible {
            display: block;
        }

        .best-score {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .legend {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.875rem;
            max-width: 600px;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            nav {
                padding: 1rem;
            }

            .nav-links {
                display: none;
            }

            h1 {
                font-size: 2rem;
            }

            .game-controls {
                flex-direction: column;
                gap: 1rem;
            }

            .memory-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="../../index.html" class="logo">Hub</a>
            <div class="nav-links">
                <a href="../gry.html" class="active">Gry</a>
                <a href="../../muzyka/muzyka.html">Muzyka</a>
                <a href="../../filmy/filmy glowna.html">Filmy</a>
                <a href="../../Programy/programy.html">NarzÄ™dzia</a>
            </div>
            <button id="theme-toggle" aria-label="PrzeÅ‚Ä…cz tryb ciemny">ðŸŒ™</button>
        </nav>
    </header>

    <main>
        <div class="game-header">
            <h1>ðŸ§  Gra w zapamiÄ™tywanie</h1>
            <p>Odkrywaj pary kolorowych kart i testuj swojÄ… pamiÄ™Ä‡!</p>
        </div>

        <div class="game-controls">
            <div class="stat">
                <span>Ruchy</span>
                <strong data-memory-moves>0</strong>
            </div>
            <div class="stat">
                <span>Czas</span>
                <strong data-memory-time>0:00</strong>
            </div>
            <div class="stat">
                <span>SkutecznoÅ›Ä‡</span>
                <strong data-memory-accuracy>100%</strong>
            </div>
            <button class="restart-btn" type="button" data-memory-reset>ðŸ”„ Restart</button>
        </div>

        <div class="memory-grid" data-memory-grid>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
            <div class="memory-card" data-card></div>
        </div>

        <div class="message" data-memory-message></div>

        <div class="best-score">
            Najlepszy wynik: <span data-memory-best-score>--</span>% Â·
            Czas: <span data-memory-best-time>--</span> Â·
            Ruchy: <span data-memory-best-moves>--</span>
        </div>

        <p class="legend">
            TwÃ³j najlepszy wynik jest zapisywany w pamiÄ™ci przeglÄ…darki. SprÃ³buj ukoÅ„czyÄ‡ planszÄ™ jak najszybciej z jak najmniejszÄ… liczbÄ… pomyÅ‚ek!
        </p>
    </main>

    <script>
        // Motyw ciemny
        const html = document.documentElement;
        const savedTheme = localStorage.getItem('theme') || 'light';
        html.setAttribute('data-theme', savedTheme);

        const themeToggle = document.getElementById('theme-toggle');
        themeToggle.textContent = savedTheme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            themeToggle.textContent = newTheme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
        });

        // Gra w zapamiÄ™tywanie
        const CARD_COLORS = [
            "red", "red",
            "green", "green",
            "blue", "blue",
            "magenta", "magenta",
            "yellow", "yellow",
            "bisque", "bisque",
            "brown", "brown",
            "cyan", "cyan",
            "orange", "orange",
        ];

        const gridElement = document.querySelector("[data-memory-grid]");
        const movesElement = document.querySelector("[data-memory-moves]");
        const timeElement = document.querySelector("[data-memory-time]");
        const accuracyElement = document.querySelector("[data-memory-accuracy]");
        const resetButton = document.querySelector("[data-memory-reset]");
        const messageElement = document.querySelector("[data-memory-message]");
        const bestScoreElement = document.querySelector("[data-memory-best-score]");
        const bestTimeElement = document.querySelector("[data-memory-best-time]");
        const bestMovesElement = document.querySelector("[data-memory-best-moves]");

        const BEST_SCORE_KEY = "memory-best-score";

        if (!gridElement) {
            console.warn("Nie znaleziono planszy gry w zapamiÄ™tywanie.");
        } else {
            const cards = Array.from(gridElement.querySelectorAll("[data-card]"));
            const state = {
                openCards: [],
                foundPairs: 0,
                moves: 0,
                startTime: null,
                timerId: null,
                isBusy: false,
            };

            const formatTime = seconds => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const updateHud = () => {
                if (movesElement) {
                    movesElement.textContent = state.moves.toString();
                }
                if (timeElement) {
                    const elapsed = state.startTime ? Math.floor((Date.now() - state.startTime) / 1000) : 0;
                    timeElement.textContent = formatTime(elapsed);
                }
                if (accuracyElement) {
                    const accuracy = state.moves === 0 ? 100 : Math.round((state.foundPairs / state.moves) * 100);
                    accuracyElement.textContent = `${Math.max(0, Math.min(accuracy, 100))}%`;
                }
            };

            const stopTimer = () => {
                if (state.timerId) {
                    clearInterval(state.timerId);
                    state.timerId = null;
                }
            };

            const startTimer = () => {
                if (!state.startTime) {
                    state.startTime = Date.now();
                    state.timerId = setInterval(updateHud, 1000);
                }
            };

            const resetMessage = () => {
                if (messageElement) {
                    messageElement.textContent = "";
                    messageElement.classList.remove("visible");
                }
            };

            const showMessage = text => {
                if (!messageElement) {
                    return;
                }
                messageElement.textContent = text;
                messageElement.classList.add("visible");
            };

            const saveBestResult = result => {
                try {
                    const stored = JSON.parse(localStorage.getItem(BEST_SCORE_KEY) || "null");
                    if (!stored || result.score > stored.score || (result.score === stored.score && result.time < stored.time)) {
                        localStorage.setItem(BEST_SCORE_KEY, JSON.stringify(result));
                        return result;
                    }
                    return stored;
                } catch (error) {
                    console.error("Nie udaÅ‚o siÄ™ zapisaÄ‡ najlepszego wyniku", error);
                    return null;
                }
            };

            const loadBestResult = () => {
                try {
                    const stored = JSON.parse(localStorage.getItem(BEST_SCORE_KEY) || "null");
                    return stored;
                } catch (error) {
                    console.error("Nie udaÅ‚o siÄ™ wczytaÄ‡ najlepszego wyniku", error);
                    return null;
                }
            };

            const updateBestSummary = best => {
                if (!best) {
                    return;
                }
                if (bestScoreElement) {
                    bestScoreElement.textContent = best.score.toString();
                }
                if (bestTimeElement) {
                    bestTimeElement.textContent = formatTime(best.time);
                }
                if (bestMovesElement) {
                    bestMovesElement.textContent = best.moves.toString();
                }
            };

            const finishGame = () => {
                stopTimer();
                const totalTime = state.startTime ? Math.floor((Date.now() - state.startTime) / 1000) : 0;
                const score = state.moves === 0 ? 100 : Math.round((state.foundPairs / state.moves) * 100);
                const result = { score, time: totalTime, moves: state.moves };
                const best = saveBestResult(result) || result;
                updateBestSummary(best);
                showMessage(`Gratulacje! UkoÅ„czyÅ‚eÅ› planszÄ™ w ${formatTime(totalTime)} i ${state.moves} ruchach.`);
            };

            const hideCards = cardsToHide => {
                cardsToHide.forEach(card => card.classList.add("hidden"));
            };

            const markAsFound = cardsToMark => {
                cardsToMark.forEach(card => card.classList.add("off"));
            };

            const revealCard = card => {
                if (state.isBusy || card.classList.contains("off") || state.openCards.includes(card)) {
                    return;
                }

                startTimer();
                resetMessage();
                card.classList.remove("hidden");
                state.openCards.push(card);

                if (state.openCards.length < 2) {
                    return;
                }

                state.isBusy = true;
                state.moves += 1;
                updateHud();

                const [first, second] = state.openCards;
                const firstColor = first.dataset.color;
                const secondColor = second.dataset.color;

                if (firstColor === secondColor) {
                    markAsFound(state.openCards);
                    state.foundPairs += 1;
                    state.openCards = [];
                    state.isBusy = false;
                    if (state.foundPairs === CARD_COLORS.length / 2) {
                        finishGame();
                    }
                } else {
                    setTimeout(() => {
                        hideCards(state.openCards);
                        state.openCards = [];
                        state.isBusy = false;
                    }, 750);
                }
            };

            const shuffleCards = () => {
                const deck = [...CARD_COLORS];
                cards.forEach(card => {
                    card.className = "memory-card";
                    const randomIndex = Math.floor(Math.random() * deck.length);
                    const color = deck.splice(randomIndex, 1)[0];
                    card.dataset.color = color;
                    card.classList.add(color);
                });
            };

            const stopHiding = () => {
                cards.forEach(card => card.classList.remove("hidden", "off"));
            };

            const resetGame = () => {
                stopTimer();
                state.openCards = [];
                state.foundPairs = 0;
                state.moves = 0;
                state.startTime = null;
                state.isBusy = false;
                cards.forEach(card => {
                    card.className = "memory-card";
                    delete card.dataset.color;
                });
                shuffleCards();
                stopHiding();
                setTimeout(() => {
                    cards.forEach(card => card.classList.add("hidden"));
                }, 1800);
                updateHud();
                resetMessage();
            };

            const initialise = () => {
                shuffleCards();
                const handleCardClick = event => revealCard(event.currentTarget);
                cards.forEach(card => {
                    card.classList.remove("hidden", "off");
                    card.addEventListener("click", handleCardClick);
                });
                setTimeout(() => {
                    cards.forEach(card => card.classList.add("hidden"));
                }, 1800);
                updateHud();
                const best = loadBestResult();
                if (best) {
                    updateBestSummary(best);
                }
            };

            if (resetButton) {
                resetButton.addEventListener("click", resetGame);
            }

            initialise();
        }
    </script>
</body>
</html>
