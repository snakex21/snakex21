<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Tetris - Hub</title>
    <link rel="icon" type="image/x-icon" href="https://www.solojuve.com/spolecznosc/zdj%C4%99cia/306-bezimienny-jpg/pobierz">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #ffffff;
            --text: #1a1a1a;
            --text-secondary: #666;
            --border: #e0e0e0;
            --card-bg: #f8f9fa;
            --header-bg: #ffffff;
            --shadow: rgba(0, 0, 0, 0.1);
            --panel-bg: #f8f9fa;
        }

        [data-theme="dark"] {
            --bg: #1a1a1a;
            --text: #ffffff;
            --text-secondary: #aaa;
            --border: #333;
            --card-bg: #2a2a2a;
            --header-bg: #1a1a1a;
            --shadow: rgba(0, 0, 0, 0.3);
            --panel-bg: #2a2a2a;
        }

        html {
            background: var(--bg);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
        }

        header {
            background: var(--header-bg);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 4px var(--shadow);
        }

        nav {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text);
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            flex: 1;
        }

        .nav-links a {
            color: var(--text-secondary);
            text-decoration: none;
        }

        .nav-links a:hover,
        .nav-links a.active {
            color: var(--text);
        }

        #theme-toggle {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
        }

        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 3rem 2rem;
        }

        .game-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .game-header p {
            color: var(--text-secondary);
            font-size: 1rem;
            margin-bottom: 1.5rem;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .stat {
            text-align: center;
        }

        .stat span {
            display: block;
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }

        .stat strong {
            font-size: 1.5rem;
            color: var(--text);
        }

        .stat.is-record strong {
            color: #22c55e;
        }

        .tetris-app {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(260px, 0.8fr);
            gap: 2rem;
            align-items: start;
            max-width: 900px;
            margin: 0 auto;
        }

        .tetris-playfield {
            position: relative;
            width: 100%;
            max-width: 440px;
            margin: 0 auto;
            padding: 1.5rem;
            border-radius: 16px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .tetris-playfield canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 12px;
            background: var(--bg);
        }

        .tetris-overlay {
            position: absolute;
            inset: 1.5rem;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(6px);
            display: grid;
            place-items: center;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .tetris-overlay.is-visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .tetris-overlay[hidden] {
            display: none !important;
        }

        .tetris-overlay__panel {
            text-align: center;
            color: #fff;
        }

        .tetris-overlay__panel h2 {
            margin: 0 0 0.5rem;
            font-size: 1.8rem;
        }

        .tetris-overlay__panel p {
            margin: 0;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.75);
        }

        .tetris-sidebar {
            display: grid;
            gap: 1.5rem;
        }

        .tetris-panel {
            background: var(--panel-bg);
            border-radius: 16px;
            border: 1px solid var(--border);
            padding: 1.5rem;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .tetris-panel h2 {
            margin: 0 0 1rem;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .tetris-next canvas {
            width: 100%;
            height: auto;
            border-radius: 12px;
            background: var(--bg);
        }

        .tetris-actions {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .tetris-actions button {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tetris-actions button[data-action="toggle"] {
            background: #3b82f6;
            color: #fff;
            border-color: #3b82f6;
        }

        .tetris-actions button[data-action="toggle"]:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        .tetris-actions button[data-action="restart"] {
            background: var(--card-bg);
            color: var(--text);
        }

        .tetris-actions button[data-action="restart"]:hover {
            background: var(--border);
        }

        .tetris-help {
            margin: 0;
            padding-left: 1.25rem;
            display: grid;
            gap: 0.4rem;
            font-size: 0.9rem;
        }

        .game-status {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        @media (max-width: 960px) {
            .tetris-app {
                grid-template-columns: 1fr;
            }

            .nav-links {
                display: none;
            }

            nav {
                padding: 1rem;
            }

            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="../../index.html" class="logo">Hub</a>
            <div class="nav-links">
                <a href="../gry.html" class="active">Gry</a>
                <a href="../../muzyka/muzyka.html">Muzyka</a>
                <a href="../../filmy/filmy glowna.html">Filmy</a>
                <a href="../../Programy/programy.html">Narzƒôdzia</a>
            </div>
            <button id="theme-toggle" aria-label="Prze≈ÇƒÖcz tryb ciemny">üåô</button>
        </nav>
    </header>

    <main>
        <div class="game-header">
            <h1>üéÆ Tetris</h1>
            <p>Uk≈Çadaj spadajƒÖce klocki, czy≈õƒá linie i bij sw√≥j rekord</p>
        </div>

        <div class="stats">
            <div class="stat">
                <span>Wynik</span>
                <strong data-tetris-score>0</strong>
            </div>
            <div class="stat">
                <span>Linie</span>
                <strong data-tetris-lines>0</strong>
            </div>
            <div class="stat">
                <span>Poziom</span>
                <strong data-tetris-level>1</strong>
            </div>
            <div class="stat" data-score-best>
                <span>Najlepszy</span>
                <strong data-tetris-best>0</strong>
            </div>
        </div>

        <div class="tetris-app">
            <div class="tetris-playfield">
                <canvas data-tetris-board width="320" height="640"></canvas>
                <div class="tetris-overlay" data-tetris-overlay hidden>
                    <div class="tetris-overlay__panel">
                        <h2 data-overlay-title>Pauza</h2>
                        <p data-overlay-subtitle>Wci≈õnij Spacjƒô, aby wr√≥ciƒá do gry</p>
                    </div>
                </div>
            </div>

            <aside class="tetris-sidebar">
                <section class="tetris-panel tetris-next">
                    <h2>Nastƒôpny klocek</h2>
                    <canvas data-tetris-preview width="144" height="144"></canvas>
                </section>

                <section class="tetris-panel">
                    <h2>Sterowanie</h2>
                    <div class="tetris-actions">
                        <button type="button" data-action="toggle">Start</button>
                        <button type="button" data-action="restart">Reset</button>
                    </div>
                    <ul class="tetris-help">
                        <li><strong>‚Üê ‚Üí</strong> ‚Äì przesuwaj klocek</li>
                        <li><strong>‚Üë / X</strong> ‚Äì obr√≥t w prawo</li>
                        <li><strong>Z</strong> ‚Äì obr√≥t w lewo</li>
                        <li><strong>‚Üì</strong> ‚Äì szybszy spadek</li>
                        <li><strong>Spacja</strong> ‚Äì pauza/wzn√≥w</li>
                        <li><strong>Shift + Spacja</strong> ‚Äì zrzut</li>
                    </ul>
                    <p class="game-status" data-status>Naci≈õnij ‚ÄûStart", aby rozpoczƒÖƒá</p>
                </section>

                <section class="tetris-panel">
                    <h2>Wskaz√≥wki</h2>
                    <ul class="tetris-help">
                        <li>Kasuj kilka linii naraz dla mno≈ºnika punkt√≥w</li>
                        <li>Co 10 wierszy gra przyspiesza o poziom</li>
                        <li>Tw√≥j rekord jest zapisywany lokalnie</li>
                    </ul>
                </section>
            </aside>
        </div>
    </main>

    <script>
        // Motyw ciemny
        const html = document.documentElement;
        const savedTheme = localStorage.getItem('theme') || 'light';
        html.setAttribute('data-theme', savedTheme);

        const themeToggle = document.getElementById('theme-toggle');
        themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            themeToggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        });

        // Tetris game
        (() => {
            const BOARD_WIDTH = 10;
            const BOARD_HEIGHT = 20;
            const CELL_SIZE = 32;
            const PREVIEW_SIZE = 6;
            const PREVIEW_CELL = 24;
            const PIECES = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
            const SHAPES = {
                I: [
                    [1, 1, 1, 1],
                ],
                J: [
                    [1, 0, 0],
                    [1, 1, 1],
                ],
                L: [
                    [0, 0, 1],
                    [1, 1, 1],
                ],
                O: [
                    [1, 1],
                    [1, 1],
                ],
                S: [
                    [0, 1, 1],
                    [1, 1, 0],
                ],
                T: [
                    [0, 1, 0],
                    [1, 1, 1],
                ],
                Z: [
                    [1, 1, 0],
                    [0, 1, 1],
                ],
            };
            const COLORS = {
                I: '#38bdf8',
                J: '#3b82f6',
                L: '#f59e0b',
                O: '#facc15',
                S: '#22c55e',
                T: '#a855f7',
                Z: '#ef4444',
            };

            const boardCanvas = document.querySelector('[data-tetris-board]');
            const previewCanvas = document.querySelector('[data-tetris-preview]');
            const boardCtx = boardCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');
            const overlay = document.querySelector('[data-tetris-overlay]');
            const overlayTitle = document.querySelector('[data-overlay-title]');
            const overlaySubtitle = document.querySelector('[data-overlay-subtitle]');
            const statusEl = document.querySelector('[data-status]');
            const toggleButton = document.querySelector('[data-action="toggle"]');
            const restartButton = document.querySelector('[data-action="restart"]');
            const scoreEl = document.querySelector('[data-tetris-score]');
            const linesEl = document.querySelector('[data-tetris-lines]');
            const levelEl = document.querySelector('[data-tetris-level]');
            const bestEl = document.querySelector('[data-tetris-best]');
            const bestCard = document.querySelector('[data-score-best]');

            boardCanvas.width = BOARD_WIDTH * CELL_SIZE;
            boardCanvas.height = BOARD_HEIGHT * CELL_SIZE;
            previewCanvas.width = PREVIEW_SIZE * PREVIEW_CELL;
            previewCanvas.height = PREVIEW_SIZE * PREVIEW_CELL;

            const state = {
                board: createMatrix(BOARD_HEIGHT, BOARD_WIDTH),
                piece: null,
                nextType: null,
                score: 0,
                lines: 0,
                level: 1,
                best: readBestScore(),
            };

            let dropCounter = 0;
            let lastTime = 0;
            let dropInterval = getDropInterval();
            let isPaused = true;
            let isGameOver = true;

            function createMatrix(rows, cols) {
                return Array.from({ length: rows }, () => Array(cols).fill(0));
            }

            function cloneMatrix(matrix) {
                return matrix.map((row) => row.slice());
            }

            function randomPiece() {
                const index = Math.floor(Math.random() * PIECES.length);
                return PIECES[index];
            }

            function createPiece(type) {
                return cloneMatrix(SHAPES[type]);
            }

            function rotateMatrix(matrix, dir) {
                const rows = matrix.length;
                const cols = matrix[0].length;
                const rotated = Array.from({ length: cols }, () => Array(rows).fill(0));

                for (let y = 0; y < rows; y += 1) {
                    for (let x = 0; x < cols; x += 1) {
                        if (dir > 0) {
                            rotated[x][rows - 1 - y] = matrix[y][x];
                        } else {
                            rotated[cols - 1 - x][y] = matrix[y][x];
                        }
                    }
                }

                return rotated;
            }

            function collide(board, piece) {
                const { matrix, pos } = piece;
                for (let y = 0; y < matrix.length; y += 1) {
                    for (let x = 0; x < matrix[y].length; x += 1) {
                        if (!matrix[y][x]) {
                            continue;
                        }
                        const boardY = y + pos.y;
                        const boardX = x + pos.x;
                        if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
                            return true;
                        }
                        if (boardY < 0) {
                            continue;
                        }
                        if (board[boardY][boardX]) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function merge(board, piece) {
                let reachedTop = false;
                piece.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (!value) {
                            return;
                        }
                        const boardY = y + piece.pos.y;
                        if (boardY < 0) {
                            reachedTop = true;
                            return;
                        }
                        board[boardY][x + piece.pos.x] = piece.type;
                    });
                });
                return reachedTop;
            }

            function clearBoard() {
                state.board = createMatrix(BOARD_HEIGHT, BOARD_WIDTH);
            }

            function drawBoard() {
                boardCtx.clearRect(0, 0, boardCanvas.width, boardCanvas.height);
                for (let y = 0; y < BOARD_HEIGHT; y += 1) {
                    for (let x = 0; x < BOARD_WIDTH; x += 1) {
                        const px = x * CELL_SIZE;
                        const py = y * CELL_SIZE;
                        boardCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                        boardCtx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                        boardCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        boardCtx.lineWidth = 1;
                        boardCtx.strokeRect(px + 0.5, py + 0.5, CELL_SIZE - 1, CELL_SIZE - 1);
                        const cell = state.board[y][x];
                        if (cell) {
                            drawBlock(boardCtx, x, y, cell, CELL_SIZE);
                        }
                    }
                }
                if (state.piece) {
                    drawMatrix(boardCtx, state.piece.matrix, state.piece.pos, state.piece.type, CELL_SIZE);
                }
            }

            function drawMatrix(ctx, matrix, offset, type, size) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (!value) {
                            return;
                        }
                        const drawX = x + offset.x;
                        const drawY = y + offset.y;
                        if (drawY < 0) {
                            return;
                        }
                        drawBlock(ctx, drawX, drawY, type, size);
                    });
                });
            }

            function drawBlock(ctx, x, y, type, size) {
                const px = x * size;
                const py = y * size;
                ctx.fillStyle = COLORS[type];
                ctx.fillRect(px, py, size, size);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(px + 1, py + 1, size - 2, size - 2);
            }

            function drawPreview() {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                if (!state.nextType) {
                    return;
                }
                const matrix = createPiece(state.nextType);
                const offsetX = Math.floor((PREVIEW_SIZE - matrix[0].length) / 2);
                const offsetY = Math.floor((PREVIEW_SIZE - matrix.length) / 2);
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (!value) {
                            return;
                        }
                        drawBlock(previewCtx, x + offsetX, y + offsetY, state.nextType, PREVIEW_CELL);
                    });
                });
            }

            function sweepLines() {
                let cleared = 0;
                for (let y = BOARD_HEIGHT - 1; y >= 0; y -= 1) {
                    if (state.board[y].every((cell) => cell)) {
                        const row = state.board.splice(y, 1)[0];
                        row.fill(0);
                        state.board.unshift(row);
                        cleared += 1;
                        y += 1;
                    }
                }
                if (cleared > 0) {
                    state.lines += cleared;
                    const lineScores = [0, 100, 300, 500, 800];
                    state.score += lineScores[cleared] * state.level;
                    const previousLevel = state.level;
                    state.level = Math.floor(state.lines / 10) + 1;
                    if (state.level !== previousLevel) {
                        dropInterval = getDropInterval();
                        updateStatus(`Nowy poziom: ${state.level}!`);
                    } else {
                        const messages = {
                            1: 'Pojedyncza linia!',
                            2: 'Podw√≥jna linia!',
                            3: 'Potr√≥jna linia!',
                            4: 'Tetris! Cztery linie naraz!',
                        };
                        updateStatus(messages[cleared] || '≈öwietnie!');
                    }
                    updateHud();
                }
                return cleared;
            }

            function spawnPiece(initial = false) {
                const type = initial ? state.nextType : state.nextType || randomPiece();
                const matrix = createPiece(type);
                state.piece = {
                    matrix,
                    pos: {
                        x: Math.floor((BOARD_WIDTH - matrix[0].length) / 2),
                        y: -2,
                    },
                    type,
                };
                state.nextType = randomPiece();
                drawPreview();

                if (collide(state.board, state.piece)) {
                    if (!initial) {
                        endGame();
                    } else {
                        state.piece.pos.y = 0;
                        if (collide(state.board, state.piece)) {
                            endGame();
                        }
                    }
                }
            }

            function playerMove(direction) {
                if (!state.piece) {
                    return;
                }
                state.piece.pos.x += direction;
                if (collide(state.board, state.piece)) {
                    state.piece.pos.x -= direction;
                }
            }

            function playerDrop() {
                if (!state.piece) {
                    return;
                }
                state.piece.pos.y += 1;
                if (collide(state.board, state.piece)) {
                    state.piece.pos.y -= 1;
                    const reachedTop = merge(state.board, state.piece);
                    if (reachedTop) {
                        endGame();
                        return;
                    }
                    sweepLines();
                    spawnPiece();
                }
                dropCounter = 0;
            }

            function hardDrop() {
                if (!state.piece) {
                    return;
                }
                let distance = 0;
                while (true) {
                    state.piece.pos.y += 1;
                    if (collide(state.board, state.piece)) {
                        state.piece.pos.y -= 1;
                        break;
                    }
                    distance += 1;
                }
                if (distance > 0) {
                    state.score += distance * 2;
                }
                const reachedTop = merge(state.board, state.piece);
                if (reachedTop) {
                    updateHud();
                    endGame();
                    return;
                }
                sweepLines();
                spawnPiece();
                dropCounter = 0;
                updateHud();
            }

            function playerRotate(direction) {
                if (!state.piece) {
                    return;
                }
                const rotated = rotateMatrix(state.piece.matrix, direction);
                const originalX = state.piece.pos.x;
                const kicks = [0, 1, -1, 2, -2];
                for (const offset of kicks) {
                    state.piece.matrix = rotated;
                    state.piece.pos.x = originalX + offset;
                    if (!collide(state.board, state.piece)) {
                        return;
                    }
                }
                state.piece.matrix = rotateMatrix(rotated, -direction);
                state.piece.pos.x = originalX;
            }

            function readBestScore() {
                try {
                    const value = localStorage.getItem('hub-tetris-best');
                    return value ? Number(value) : 0;
                } catch (error) {
                    return 0;
                }
            }

            function saveBestScore(value) {
                try {
                    localStorage.setItem('hub-tetris-best', String(value));
                } catch (error) {
                    /* Ignorujemy brak dostƒôpu do localStorage */
                }
            }

            function updateHud() {
                if (state.score > state.best) {
                    state.best = state.score;
                    saveBestScore(state.best);
                    bestCard.classList.add('is-record');
                    updateStatus('Nowy rekord!');
                }
                scoreEl.textContent = state.score;
                linesEl.textContent = state.lines;
                levelEl.textContent = state.level;
                bestEl.textContent = state.best;
            }

            function updateStatus(message) {
                if (message) {
                    statusEl.textContent = message;
                }
            }

            function getDropInterval() {
                return Math.max(1000 - (state.level - 1) * 80, 140);
            }

            function showOverlay(title, subtitle) {
                overlayTitle.textContent = title;
                overlaySubtitle.textContent = subtitle;
                overlay.hidden = false;
                overlay.classList.add('is-visible');
            }

            function hideOverlay() {
                overlay.classList.remove('is-visible');
                overlay.hidden = true;
            }

            function startGame() {
                clearBoard();
                state.score = 0;
                state.lines = 0;
                state.level = 1;
                state.nextType = randomPiece();
                spawnPiece(true);
                dropInterval = getDropInterval();
                dropCounter = 0;
                isPaused = false;
                isGameOver = false;
                toggleButton.textContent = 'Pauza';
                statusEl.textContent = 'Uk≈Çadaj klocki i czy≈õƒá linie, by zdobywaƒá punkty';
                bestCard.classList.remove('is-record');
                hideOverlay();
                updateHud();
            }

            function pauseGame() {
                if (isGameOver || isPaused) {
                    return;
                }
                isPaused = true;
                toggleButton.textContent = 'Wzn√≥w';
                showOverlay('Pauza', 'Wci≈õnij Spacjƒô lub ‚ÄûWzn√≥w", aby kontynuowaƒá');
                updateStatus('Gra wstrzymana');
            }

            function resumeGame() {
                if (isGameOver || !isPaused) {
                    return;
                }
                isPaused = false;
                toggleButton.textContent = 'Pauza';
                hideOverlay();
            }

            function endGame() {
                isPaused = true;
                isGameOver = true;
                state.piece = null;
                toggleButton.textContent = 'Zagraj ponownie';
                showOverlay('Koniec gry', `Tw√≥j wynik: ${state.score}`);
                updateStatus('Gra zako≈Ñczona. Spr√≥buj pobiƒá rekord!');
                updateHud();
            }

            function update(time = 0) {
                const delta = time - lastTime;
                lastTime = time;

                if (!isPaused && !isGameOver) {
                    dropCounter += delta;
                    if (dropCounter > dropInterval) {
                        playerDrop();
                    }
                }

                drawBoard();
                requestAnimationFrame(update);
            }

            function handleKeydown(event) {
                const focused = document.activeElement;
                if (focused && (focused.tagName === 'INPUT' || focused.tagName === 'TEXTAREA' || focused.isContentEditable)) {
                    return;
                }
                switch (event.code) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        if (!isPaused && !isGameOver) {
                            playerMove(-1);
                        }
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        if (!isPaused && !isGameOver) {
                            playerMove(1);
                        }
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        if (!isPaused && !isGameOver) {
                            state.score += 1;
                            playerDrop();
                            updateHud();
                        }
                        break;
                    case 'ArrowUp':
                    case 'KeyX':
                        event.preventDefault();
                        if (!isPaused && !isGameOver) {
                            playerRotate(1);
                        }
                        break;
                    case 'KeyZ':
                        event.preventDefault();
                        if (!isPaused && !isGameOver) {
                            playerRotate(-1);
                        }
                        break;
                    case 'Space':
                        event.preventDefault();
                        if (isGameOver) {
                            startGame();
                        } else if (isPaused) {
                            resumeGame();
                        } else if (event.shiftKey) {
                            hardDrop();
                        } else {
                            pauseGame();
                        }
                        break;
                    case 'KeyP':
                        event.preventDefault();
                        if (isPaused && !isGameOver) {
                            resumeGame();
                        } else if (!isPaused && !isGameOver) {
                            pauseGame();
                        }
                        break;
                    default:
                        break;
                }
            }

            toggleButton.addEventListener('click', () => {
                if (isGameOver) {
                    startGame();
                } else if (isPaused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            });

            restartButton.addEventListener('click', () => {
                startGame();
            });

            document.addEventListener('keydown', handleKeydown);

            update();
            drawPreview();
        })();
    </script>
</body>
</html>
