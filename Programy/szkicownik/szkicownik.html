<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Szkicownik - Hub</title>
    <link rel="icon" type="image/x-icon" href="https://www.solojuve.com/spolecznosc/zdj%C4%99cia/306-bezimienny-jpg/pobierz">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #ffffff;
            --text: #1a1a1a;
            --text-secondary: #666;
            --border: #e0e0e0;
            --card-bg: #f8f9fa;
            --card-hover: #e9ecef;
            --header-bg: #ffffff;
            --shadow: rgba(0, 0, 0, 0.1);
            --accent: #d946ef;
            --canvas-bg: #ffffff;
        }

        [data-theme="dark"] {
            --bg: #1a1a1a;
            --text: #ffffff;
            --text-secondary: #aaa;
            --border: #333;
            --card-bg: #2a2a2a;
            --card-hover: #3a3a3a;
            --header-bg: #1a1a1a;
            --shadow: rgba(0, 0, 0, 0.3);
            --accent: #e879f9;
            --canvas-bg: #fff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }

        header {
            background: var(--header-bg);
            border-bottom: 1px solid var(--border);
            z-index: 100;
            box-shadow: 0 2px 4px var(--shadow);
            flex-shrink: 0;
        }

        nav {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .logo { font-size: 1.5rem; font-weight: 700; color: var(--text); text-decoration: none; }
        .nav-links { display: flex; gap: 2rem; flex: 1; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; transition: 0.2s; }
        .nav-links a:hover, .nav-links a.active { color: var(--text); }
        #theme-toggle { background: none; border: none; font-size: 1.5rem; cursor: pointer; padding: 0.25rem; }

        /* Toolbar */
        .toolbar {
            background: var(--card-bg);
            border-bottom: 1px solid var(--border);
            padding: 0.8rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            z-index: 10;
        }

        .tool-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            border-right: 1px solid var(--border);
            padding-right: 1rem;
        }
        .tool-group:last-child { border-right: none; }

        .btn-tool {
            width: 40px; height: 40px;
            border: 1px solid var(--border);
            background: var(--bg);
            border-radius: 8px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .btn-tool:hover { background: var(--card-hover); }
        .btn-tool.active { background: var(--accent); color: white; border-color: var(--accent); }

        input[type="color"] { width: 40px; height: 40px; border: none; background: none; cursor: pointer; }
        input[type="range"] { width: 100px; accent-color: var(--accent); }
        #img-upload { display: none; }

        .canvas-container {
            flex: 1;
            background: #e5e5e5;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        canvas {
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-radius: 4px;
        }

        /* Cursor styles for tools */
        .cursor-draw { cursor: crosshair; }
        .cursor-move { cursor: move; }
        .cursor-text { cursor: text; }

        @media (max-width: 768px) {
            nav { padding: 1rem; }
            .nav-links { display: none; }
            .toolbar { padding: 0.5rem; gap: 0.5rem; overflow-x: auto; justify-content: flex-start; }
            .tool-group { padding-right: 0.5rem; }
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="../../index.html" class="logo">Hub</a>
            <div class="nav-links">
                <a href="../../gry/gry.html">Gry</a>
                <a href="../../muzyka/muzyka.html">Muzyka</a>
                <a href="../../filmy/filmy glowna.html">Filmy</a>
                <a href="../programy.html" class="active">Narzƒôdzia</a>
            </div>
            <button id="theme-toggle">üåô</button>
        </nav>
    </header>

    <div class="toolbar">
        <div class="tool-group">
            <button class="btn-tool active" id="tool-brush" title="Pƒôdzel">‚úèÔ∏è</button>
            <button class="btn-tool" id="tool-eraser" title="Gumka">üßº</button>
            <button class="btn-tool" id="tool-text" title="Tekst">üî§</button>
            <button class="btn-tool" id="tool-select" title="Zaznacz i przesu≈Ñ">‚úÇÔ∏è</button>
        </div>
        
        <div class="tool-group">
            <input type="color" id="color-picker" value="#000000" title="Kolor">
            <input type="range" id="size-picker" min="1" max="50" value="5" title="Grubo≈õƒá / Rozmiar">
        </div>

        <div class="tool-group">
            <label for="img-upload" class="btn-tool" title="Wgraj zdjƒôcie">üñºÔ∏è</label>
            <input type="file" id="img-upload" accept="image/*">

            <button class="btn-tool" id="action-undo" title="Cofnij">‚Ü©Ô∏è</button>
            <button class="btn-tool" id="action-clear" title="Wyczy≈õƒá wszystko" style="color: #ef4444;">üóëÔ∏è</button>
            <button class="btn-tool" id="action-save" title="Zapisz" style="color: #10b981;">üíæ</button>
        </div>
    </div>

    <div class="canvas-container" id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // --- THEME ---
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;
        const savedTheme = localStorage.getItem('theme') || 'light';
        html.setAttribute('data-theme', savedTheme);
        themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            themeToggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        });

        // --- DRAWING ENGINE ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        
        // Tools
        const tools = {
            brush: document.getElementById('tool-brush'),
            eraser: document.getElementById('tool-eraser'),
            text: document.getElementById('tool-text'),
            select: document.getElementById('tool-select')
        };
        
        const colorPicker = document.getElementById('color-picker');
        const sizePicker = document.getElementById('size-picker');
        const btnUndo = document.getElementById('action-undo');
        const btnClear = document.getElementById('action-clear');
        const btnSave = document.getElementById('action-save');
        const imgUpload = document.getElementById('img-upload');

        let isDrawing = false;
        let currentTool = 'brush';
        let history = [];
        let historyStep = -1;

        // Selection / Move Variables
        let isSelecting = false;
        let isMoving = false;
        let startX, startY; // Start coords for selection box
        let selection = null; // { x, y, w, h, imageData, canvasSnapshot }
        let dragOffset = { x: 0, y: 0 };

        // --- INIT & RESIZE ---
        function resizeCanvas() {
            const width = Math.min(container.offsetWidth - 40, 1200);
            const height = Math.min(container.offsetHeight - 40, 800);
            
            let temp;
            if (canvas.width > 0) temp = ctx.getImageData(0,0, canvas.width, canvas.height);

            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (temp) ctx.putImageData(temp, 0, 0);
            if (historyStep === -1) saveState();
        }

        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);

        // --- MOUSE EVENTS ---
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX || e.touches[0].clientX) - rect.left,
                y: (e.clientY || e.touches[0].clientY) - rect.top
            };
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); });

        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); });

        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleEnd(e); });
        canvas.addEventListener('mouseout', handleEnd);

        // --- HANDLERS ---

        function handleStart(e) {
            const { x, y } = getCoords(e);

            if (currentTool === 'text') {
                handleTextTool(x, y);
                return;
            }

            if (currentTool === 'select') {
                // If we have a selection and click inside it -> Start Moving
                if (selection && 
                    x >= selection.x && x <= selection.x + selection.w &&
                    y >= selection.y && y <= selection.y + selection.h) {
                    
                    isMoving = true;
                    dragOffset.x = x - selection.x;
                    dragOffset.y = y - selection.y;
                    canvas.style.cursor = 'move';
                } else {
                    // Click outside -> Commit previous selection and start new one
                    if (selection) commitSelection();
                    
                    isSelecting = true;
                    startX = x;
                    startY = y;
                    // Save snapshot BEFORE drawing the selection box
                    selection = { canvasSnapshot: canvas.toDataURL() }; 
                }
                return;
            }

            // Normal Drawing
            if (selection) commitSelection(); // Auto-commit if changing from select to draw
            isDrawing = true;
            ctx.beginPath();
            ctx.moveTo(x, y);
            draw(x, y);
        }

        function handleMove(e) {
            const { x, y } = getCoords(e);

            if (currentTool === 'select') {
                if (isSelecting) {
                    // Restore clean state to remove previous rectangle
                    const img = new Image();
                    img.src = selection.canvasSnapshot;
                    // We need immediate redraw, so we skip onload for smoothness (assuming DataURL is fast enough in RAM)
                    ctx.drawImage(img, 0, 0); 
                    
                    // Draw dashed rectangle
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = '#d946ef';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(startX, startY, x - startX, y - startY);
                    ctx.setLineDash([]);
                } else if (isMoving && selection.imageData) {
                    // Clear canvas to the state with the HOLE
                    const bgImg = new Image();
                    bgImg.src = selection.backgroundSnapshot;
                    ctx.drawImage(bgImg, 0, 0);

                    // Update position
                    selection.x = x - dragOffset.x;
                    selection.y = y - dragOffset.y;

                    // Draw the floating selection
                    // We need a temp canvas to convert ImageData to drawable image
                    const tempCan = document.createElement('canvas');
                    tempCan.width = selection.w;
                    tempCan.height = selection.h;
                    tempCan.getContext('2d').putImageData(selection.imageData, 0, 0);
                    
                    ctx.drawImage(tempCan, selection.x, selection.y);
                }
                return;
            }

            if (isDrawing) {
                draw(x, y);
            }
        }

        function handleEnd(e) {
            if (currentTool === 'select') {
                if (isSelecting) {
                    isSelecting = false;
                    const { x, y } = getCoords(e); // End coords
                    
                    let w = x - startX;
                    let h = y - startY;

                    // Normalize negative width/height
                    if (w < 0) { startX = x; w = Math.abs(w); }
                    if (h < 0) { startY = y; h = Math.abs(h); }

                    if (w < 5 || h < 5) {
                        // Clicked without dragging -> Cancel
                        const img = new Image();
                        img.src = selection.canvasSnapshot;
                        img.onload = () => ctx.drawImage(img, 0, 0);
                        selection = null;
                        return;
                    }

                    // Restore to clean state (remove dashed box)
                    const img = new Image();
                    img.src = selection.canvasSnapshot;
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0);
                        
                        // 1. Grab pixels
                        const selectedData = ctx.getImageData(startX, startY, w, h);
                        
                        // 2. Cut (Fill white)
                        ctx.fillStyle = "#ffffff";
                        ctx.fillRect(startX, startY, w, h);
                        
                        // 3. Save state with HOLE
                        const backgroundWithHole = canvas.toDataURL();

                        // 4. Update selection object
                        selection = {
                            x: startX,
                            y: startY,
                            w: w,
                            h: h,
                            imageData: selectedData,
                            backgroundSnapshot: backgroundWithHole
                        };

                        // 5. Immediately draw the image back on top (so it looks like it's selected)
                        const tempCan = document.createElement('canvas');
                        tempCan.width = w; tempCan.height = h;
                        tempCan.getContext('2d').putImageData(selectedData, 0, 0);
                        ctx.drawImage(tempCan, startX, startY);
                        
                        // Draw selection border
                        ctx.setLineDash([5, 5]);
                        ctx.strokeStyle = '#d946ef';
                        ctx.strokeRect(startX, startY, w, h);
                        ctx.setLineDash([]);
                    };
                } else if (isMoving) {
                    isMoving = false;
                    canvas.style.cursor = 'default';
                }
                return;
            }

            if (isDrawing) {
                isDrawing = false;
                ctx.beginPath();
                saveState();
            }
        }

        // --- TOOL LOGIC ---

        function draw(x, y) {
            ctx.lineWidth = sizePicker.value;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (currentTool === 'brush') {
                ctx.strokeStyle = colorPicker.value;
            } else if (currentTool === 'eraser') {
                ctx.strokeStyle = '#ffffff';
            }

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function handleTextTool(x, y) {
            const text = prompt("Wpisz tekst:", "");
            if (text) {
                const size = sizePicker.value * 3;
                ctx.font = `${size}px sans-serif`;
                ctx.fillStyle = colorPicker.value;
                ctx.fillText(text, x, y);
                saveState();
            }
        }

        function commitSelection() {
            if (!selection) return;
            // The canvas currently has the drawing from the last 'mousemove'
            // which includes the background hole + the image at new position.
            // We just need to save this as the new permanent state.
            selection = null;
            saveState();
            
            // Redraw to remove any potential selection artifacts (like border if we added it)
            // But since 'handleMove' draws clean image, we are mostly good.
        }

        // --- HISTORY & UTILS ---
        function saveState() {
            historyStep++;
            if (historyStep < history.length) history.length = historyStep;
            history.push(canvas.toDataURL());
            if (history.length > 20) { history.shift(); historyStep--; }
        }

        function undo() {
            if (selection) { 
                // Undo while selecting -> Cancel selection, restore original
                const img = new Image();
                img.src = selection.backgroundSnapshot || selection.canvasSnapshot; // Fallback
                img.onload = () => ctx.drawImage(img, 0, 0);
                selection = null;
                return;
            }

            if (historyStep > 0) {
                historyStep--;
                const img = new Image();
                img.src = history[historyStep];
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
            }
        }

        function setActiveTool(tool) {
            if(selection) commitSelection();
            
            currentTool = tool;
            Object.values(tools).forEach(btn => btn.classList.remove('active'));
            tools[tool].classList.add('active');

            if(tool === 'select') canvas.style.cursor = 'crosshair';
            else if(tool === 'text') canvas.style.cursor = 'text';
            else canvas.style.cursor = 'crosshair';
        }

        // --- LISTENERS ---
        Object.keys(tools).forEach(key => {
            tools[key].addEventListener('click', () => setActiveTool(key));
        });

        btnUndo.addEventListener('click', undo);
        btnClear.addEventListener('click', () => {
            if (confirm('Wyczy≈õciƒá?')) {
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                selection = null;
                saveState();
            }
        });
        btnSave.addEventListener('click', () => {
            if(selection) commitSelection();
            const link = document.createElement('a');
            link.download = `szkic_${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });

        // Image Upload & Paste
        function drawImage(src) {
            if(selection) commitSelection();
            const img = new Image();
            img.src = src;
            img.onload = () => {
                // Scale & Center
                const scale = Math.min(canvas.width / img.width, canvas.height / img.height, 1);
                const w = img.width * scale;
                const h = img.height * scale;
                const x = (canvas.width - w) / 2;
                const y = (canvas.height - h) / 2;
                ctx.drawImage(img, x, y, w, h);
                saveState();
            };
        }

        imgUpload.addEventListener('change', (e) => {
            if(e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (ev) => drawImage(ev.target.result);
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        window.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let item of items) {
                if (item.type.indexOf('image') === 0) {
                    const blob = item.getAsFile();
                    drawImage(URL.createObjectURL(blob));
                }
            }
        });

        // Key Shortcuts
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
            if (e.key === 'Delete' && selection) { 
                // Delete selected area (fill with white in background snapshot)
                const bgImg = new Image();
                bgImg.src = selection.backgroundSnapshot;
                bgImg.onload = () => {
                    ctx.drawImage(bgImg, 0, 0); // Background already has the hole
                    selection = null;
                    saveState();
                };
            }
        });

    </script>
</body>
</html>